<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Niu Niu</title>

  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#111111"/>

  <style>
    body { font-family: -apple-system, system-ui, Arial; margin: 18px; }
    h2 { margin: 0 0 10px; }
    .box { border:1px solid #ddd; border-radius:16px; padding:14px; margin-top:12px; }
    .muted { color:#555; font-size: 14px; line-height: 1.4; }
    .good { color:#0a7a2f; }
    .bad { color:#b00020; }

    .grid {
      display: grid;
      grid-template-columns: repeat(4, minmax(70px, 1fr));
      gap: 10px;
      margin-top: 10px;
    }

    button.card {
      position: relative;
      padding: 12px 10px;
      font-size: 18px;
      border-radius: 14px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    button.card:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .badge {
      position:absolute;
      top: -8px;
      right: -8px;
      min-width: 24px;
      height: 24px;
      padding: 0 6px;
      border-radius: 999px;
      border: 1px solid #111;
      background:#111;
      color:#fff;
      font-size: 13px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }

    button.action {
      padding: 12px 14px;
      font-size: 16px;
      border-radius: 14px;
      border: 1px solid #ccc;
      background: #f7f7f7;
      cursor: pointer;
      touch-action: manipulation;
    }

    .selectedBar {
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      margin-top:10px;
    }
    .pill {
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid #ddd;
      background:#fafafa;
      font-size: 14px;
      user-select: none;
    }
    .pill button {
      border:1px solid #ccc;
      background:#fff;
      border-radius:999px;
      padding:4px 8px;
      cursor:pointer;
      font-size: 14px;
      line-height: 1;
      touch-action: manipulation;
    }

    .tag { display:inline-block; padding:6px 10px; border-radius:999px; border:1px solid #ddd; margin:6px 6px 0 0; }
  </style>
</head>

<body>
  <h2>Niu Niu Calculator</h2>

  <div class="box">
    <div><b>Tap to add cards</b> <span class="muted" id="countHint">(0 / 5)</span></div>

    <div class="grid" id="cardGrid"></div>

    <div class="selectedBar" id="selectedBar"></div>

    <div class="row">
      <button class="action" id="resetBtn">Reset</button>
    </div>

    <div class="muted" style="margin-top:10px;">
      To everyone using this â€” Heng Ong Huat! ğŸ®ğŸ’°
    </div>
  </div>

  <div class="box">
    <div id="result"></div>
  </div>

  <!-- Version shown BELOW the result box -->
  <div id="versionBelow" class="muted" style="margin-top:8px; font-size:12px; color:#aaa;"></div>

<script>
  // ===== Version (change here only) =====
  const APP_VERSION = "1.11";

  // Offline support
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').catch(()=>{});
  }

  /**
   * Tap handler:
   * - uses touchend + preventDefault to reduce iOS double-tap zoom
   * - still allows rapid repeated taps
   * - avoids click firing after touch
   */
  let lastTouchAt = 0;
  function addTapListener(el, fn) {
    el.addEventListener('touchend', (e) => {
      e.preventDefault();
      lastTouchAt = Date.now();
      fn(e);
    }, { passive: false });

    el.addEventListener('click', (e) => {
      if (Date.now() - lastTouchAt < 650) return;
      fn(e);
    });
  }

  // Optional: block pinch/gesture zoom on iOS Safari
  ['gesturestart','gesturechange','gestureend'].forEach(type => {
    document.addEventListener(type, (e) => e.preventDefault(), { passive:false });
  });

  // 14 options (Aâ™  behind K)
  const OPTIONS = [
    { id:'A',  label:'A',  rankGroup:'A' },
    ...Array.from({length:9}, (_,i)=>({ id:String(i+2), label:String(i+2), rankGroup:String(i+2) })),
    { id:'J', label:'J', rankGroup:'J' },
    { id:'Q', label:'Q', rankGroup:'Q' },
    { id:'K', label:'K', rankGroup:'K' },
    { id:'AS', label:'Aâ™ ', rankGroup:'A' },
  ];

  function findOpt(id){ return OPTIONS.find(o=>o.id===id); }
  function labelOf(id){ return findOpt(id)?.label ?? id; }
  function rankGroupOf(id){ return findOpt(id)?.rankGroup ?? id; }
  function isFaceJQK(id){ return id === 'J' || id === 'Q' || id === 'K'; }

  // äº”å¼ é¬¼: all 5 cards are J/Q/K
  function isFiveGhost(cards5){
    return cards5.length === 5 && cards5.every(isFaceJQK);
  }

  // possible numeric values (3/6 flexible)
  function possibleValues(cardId){
    if (cardId === 'AS') return [1];
    if (cardId === 'A')  return [1];
    if (isFaceJQK(cardId)) return [10];
    if (cardId === '10') return [10];
    if (cardId === '3' || cardId === '6') return [3,6];
    return [parseInt(cardId,10)];
  }

  // last digit, but 0 -> 10
  function scoreFromSum(sum){
    const mod = sum % 10;
    return (mod === 0) ? 10 : mod;
  }

  // best scoring for leftover 2 cards
  function bestLeftoverScore(cardA, cardB){
    const va = possibleValues(cardA);
    const vb = possibleValues(cardB);
    let best = { score: -1, sum: null, usedA: null, usedB: null };

    for (const a of va){
      for (const b of vb){
        const sum = a + b;
        const score = scoreFromSum(sum);
        if (score > best.score){
          best = { score, sum, usedA: a, usedB: b };
        }
      }
    }
    return best;
  }

  // any assignment for 3 cards can be multiple of 10?
  function canMakeMultipleOf10(cards3){
    const vals = cards3.map(possibleValues);
    for (const a of vals[0]){
      for (const b of vals[1]){
        for (const c of vals[2]){
          const sum = a+b+c;
          if (sum % 10 === 0) return { ok:true, sum, used:[a,b,c] };
        }
      }
    }
    return { ok:false };
  }

  // Tier priority (lower is better):
  // 1 ç‰›å†¬è‡, 2 äº”å¼ é¬¼, 3 Pair, 4 ç‰›ç‰›(10), 5 ç‰›1-9
  function tierOfCandidate(c){
    if (c.isDongGu) return 1;
    if (c.isFiveGhost) return 2;
    if (c.isPair) return 3;
    if (c.points === 10) return 4;
    return 5;
  }

  // Evaluate ALL valid ç‰› splits and choose best by tier first, then points
  function evaluate(cards5){
    if (isFiveGhost(cards5)){
      return { isFiveGhost: true, tier: 2 };
    }

    const idx = [0,1,2,3,4];
    let best = null;

    for (let i=0;i<5;i++){
      for (let j=i+1;j<5;j++){
        for (let k=j+1;k<5;k++){
          const tripleIdx = [i,j,k];
          const tripleCards = [cards5[i], cards5[j], cards5[k]];
          const tripleCheck = canMakeMultipleOf10(tripleCards);
          if (!tripleCheck.ok) continue;

          const restIdx = idx.filter(x => !tripleIdx.includes(x));
          const leftA = cards5[restIdx[0]];
          const leftB = cards5[restIdx[1]];
          const leftBest = bestLeftoverScore(leftA, leftB);

          // ç‰›å†¬è‡: Aâ™  + J/Q/K in ç‚¹æ•°
          const isDongGu =
            (leftA === 'AS' && isFaceJQK(leftB)) ||
            (leftB === 'AS' && isFaceJQK(leftA));

          // Pair: same rank group (Aâ™  + A => Pair A)
          const isPair = rankGroupOf(leftA) === rankGroupOf(leftB);

          const candidate = {
            isFiveGhost: false,
            isDongGu,
            isPair,
            points: leftBest.score,

            tripleIdx,
            tripleUsedValues: tripleCheck.used,
            tripleSum: tripleCheck.sum,

            leftA, leftB,
            leftUsedA: leftBest.usedA,
            leftUsedB: leftBest.usedB,
            leftSum: leftBest.sum
          };

          candidate.tier = tierOfCandidate(candidate);

          if (!best){ best = candidate; continue; }

          // Tier first
          if (candidate.tier < best.tier) { best = candidate; continue; }
          if (candidate.tier > best.tier) continue;

          // Same tier: higher points
          if (candidate.points > best.points) { best = candidate; continue; }
        }
      }
    }

    return best; // null => æ— ç‰›
  }

  // --- UI State (duplicates allowed) ---
  let selected = [];

  function counts(){
    const m = new Map();
    for (const id of selected) m.set(id, (m.get(id)||0)+1);
    return m;
  }

  function addCard(id){
    document.getElementById('result').innerHTML = '';
    if (selected.length >= 5) return;

    selected.push(id);
    render();

    if (selected.length === 5) calculate(); // auto-calc
  }

  function removeOne(id){
    document.getElementById('result').innerHTML = '';
    const ix = selected.indexOf(id);
    if (ix >= 0) selected.splice(ix, 1);
    render();
  }

  function resetAll(){
    selected = [];
    document.getElementById('result').innerHTML = '';
    render();
  }

  function render(){
    document.getElementById('countHint').textContent = `(${selected.length} / 5)`;

    const disableAdds = selected.length >= 5;
    const c = counts();

    for (const opt of OPTIONS){
      const btn = document.getElementById('btn_'+opt.id);
      btn.disabled = disableAdds;

      const badge = document.getElementById('badge_'+opt.id);
      const n = c.get(opt.id) || 0;
      if (n > 0){
        badge.textContent = n;
        badge.style.display = 'flex';
      } else {
        badge.style.display = 'none';
      }
    }

    const bar = document.getElementById('selectedBar');
    bar.innerHTML = '';
    if (selected.length === 0){
      bar.innerHTML = `<span class="muted">Selected: none</span>`;
      return;
    }

    for (const opt of OPTIONS){
      const n = c.get(opt.id) || 0;
      if (n <= 0) continue;

      const pill = document.createElement('span');
      pill.className = 'pill';
      pill.innerHTML = `<b>${opt.label}</b> Ã— ${n}`;

      const minus = document.createElement('button');
      minus.textContent = 'â–';
      minus.title = 'Remove one';
      addTapListener(minus, () => removeOne(opt.id));

      pill.appendChild(minus);
      bar.appendChild(pill);
    }
  }

  function calculate(){
    if (selected.length !== 5) return;

    const best = evaluate(selected);
    const resultEl = document.getElementById('result');

    // æ— ç‰›
    if (!best){
      resultEl.innerHTML = `
        <div class="bad"><b>Result:</b> æ— ç‰›</div>
        <div style="margin-top:6px;">
          <span class="tag">ğŸ˜Ÿ æ— ç‰›...</span>
        </div>
      `;
      return;
    }

    // äº”å¼ é¬¼
    if (best.isFiveGhost){
      resultEl.innerHTML = `
        <div class="good"><b>Result:</b> äº”å¼ é¬¼</div>
        <div style="margin-top:6px;">
          <span class="tag">ğŸ‰ äº”å¼ é¬¼!!!!</span>
        </div>
      `;
      return;
    }

    // Result label
    let resultLabel = '';
    if (best.isDongGu) {
      resultLabel = 'ç‰›å†¬è‡';
    } else if (best.isPair) {
      resultLabel = `Pair ${rankGroupOf(best.leftA)}`;
    } else if (best.points === 10) {
      resultLabel = 'ç‰›ç‰› (10)';
    } else {
      resultLabel = `ç‰› ${best.points}`;
    }

    // Tags
    const tags = [];
    if (best.isDongGu) tags.push(`<span class="tag">ğŸ¥³ ç‰›å†¬è‡!!!!!</span>`);
    if (best.isPair) tags.push(`<span class="tag">ğŸ‚¡ğŸ‚¡ Pair Cards!!!</span>`);
    if (!best.isDongGu && !best.isPair && best.points === 10) tags.push(`<span class="tag">ç‰›ç‰›!! (10)</span>`);

    const tripleExplain = best.tripleIdx.map((ix, t) => {
      const cid = selected[ix];
      return `${labelOf(cid)}â†’${best.tripleUsedValues[t]}`;
    }).join(' + ');

    const la = labelOf(best.leftA);
    const lb = labelOf(best.leftB);

    resultEl.innerHTML = `
      <div class="good"><b>Result:</b> ${resultLabel}</div>
      <div style="margin-top:6px;">${tags.join(' ')}</div>

      <div style="margin-top:10px;">
        <b>ç‰› (multiple of 10):</b><br>
        ${tripleExplain} = <b>${best.tripleSum}</b>
      </div>

      <div style="margin-top:10px;">
        <b>ç‚¹æ•°:</b><br>
        ${la}â†’${best.leftUsedA} + ${lb}â†’${best.leftUsedB}
        = <b>${best.leftSum}</b> â†’ ç‚¹æ•° = <b>${best.points}</b>
      </div>

      <div class="muted" style="margin-top:10px;">
        3 & 6 can be treated as 3 or 6; calculator chooses the best outcome automatically.
      </div>
    `;
  }

  function init(){
    // show version below result box
    document.getElementById('versionBelow').textContent = `v${APP_VERSION}`;

    // Reset button
    addTapListener(document.getElementById('resetBtn'), resetAll);

    // Card grid buttons
    const grid = document.getElementById('cardGrid');
    for (const opt of OPTIONS){
      const btn = document.createElement('button');
      btn.className = 'card';
      btn.id = 'btn_' + opt.id;
      btn.textContent = opt.label;

      const badge = document.createElement('div');
      badge.className = 'badge';
      badge.id = 'badge_' + opt.id;
      badge.style.display = 'none';
      btn.appendChild(badge);

      addTapListener(btn, () => addCard(opt.id));
      grid.appendChild(btn);
    }

    render();
  }

  init();
</script>
</body>
</html>
